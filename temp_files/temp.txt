# Configure application
app = Flask(__name__)

# Custom filter
app.jinja_env.filters["usd"] = usd

# Configure session to use filesystem (instead of signed cookies)
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)

# Configure CS50 Library to use SQLite database
db = SQL("sqlite:///finance.db")

# Make sure API key is set
if not os.environ.get("API_KEY"):
    raise RuntimeError("API_KEY not set")


@app.after_request
def after_request(response):
    """Ensure responses aren't cached"""
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
    response.headers["Expires"] = 0
    response.headers["Pragma"] = "no-cache"
    return response


@app.route("/login", methods=["GET", "POST"])
def login():
    """Log user in"""

    # Forget any user_id
    session.clear()

    # User reached route via POST (as by submitting a form via POST)
    if request.method == "POST":

        # Ensure username was submitted
        if not request.form.get("username"):
            return apology("must provide username", 403)

        # Ensure password was submitted
        elif not request.form.get("password"):
            return apology("must provide password", 403)

        # Query database for username
        rows = db.execute("SELECT * FROM users WHERE username = ?", request.form.get("username"))

        # Ensure username exists and password is correct
        if len(rows) != 1 or not check_password_hash(rows[0]["hash"], request.form.get("password")):
            return apology("invalid username and/or password", 403)

        # Remember which user has logged in
        session["user_id"] = rows[0]["id"]

        # Redirect user to home page
        return redirect("/")

    # User reached route via GET (as by clicking a link or via redirect)
    else:
        return render_template("login.html")


@app.route("/logout")
def logout():
    """Log user out"""

    # Forget any user_id
    session.clear()

    # Redirect user to login form
    return redirect("/")


@app.route("/register", methods=["GET", "POST"])
def register():
    """Register user"""

    if request.method == "POST":
        # Ensures username was submitted
        if not request.form.get("username"):
            return apology("must provide username", 400)

        # Is username id database
        elif db.execute("SELECT * FROM users WHERE username = ?", request.form.get("username")):
            return apology("sorry username already exists", 400)

        # Ensures password was submitted
        elif not request.form.get("password"):
            return apology("must provide password", 400)

        # Confirm password is correct
        elif not request.form.get("password") == request.form.get("confirmation"):
            return apology("your passwords don't match")

        # If username and password are vaild, store in database
        else:
            username = request.form.get("username")
            password = generate_password_hash(request.form.get("password"))
            db.execute("INSERT INTO users (username, hash) VALUES(?, ?)", username, password)
            login()
            flash("Registered")
            return redirect("/")
    else:
        return render_template("register.html")


AMOUNT SORT FUNCTION:

function sortTable() {
    let table = document.getElementById('transaction-table');
    let rows = table.getElementsByTagName('tr');
    let row1;
    let row2;
    let x;
    let y;
    let temp = rows[1]
    let sorted = [];
    // loop through array until it is sorted
    for (let i = 1; i < (rows.length); i++) {
        // for each time throught array
        for (let i = 1; i < (rows.lenght); i++) {     
            // get the TD element for temp and rows[i + 1]
            row1 = rows[i].getElementsByClassName('amount').innerHTML;
            row2 = rows[i + 1].getElementsByClassName('amount').innerHTML;
            // Get the values for the rows
            x = Math.abs(parseFloat(row1[0]));
            y = Math.abs(parseFloat(row2[0]));
            // If temp is less than rows[i + 1]
            if (x > y) {
                // Set temp to the lesser row
                temp = rows[i + 1]
            }
        }
    }
}



        let temp1 = rowsArr[xp];
        let temp2 = rowsArr[yp];
        rowsArr.splice(xp, 1, temp2);
        rowsArr.splice(yp, 1, temp1);




AMOUNTSORT BROKEN:

function amountSort(){
    // access the table to bet the rows
    let table = document.getElementById('transaction-table');
    let rowsArr = table.rows;
    // get the number of rows in a the table
    let n = rowsArr.length;
    //console.log(n);
    selectionSort(rowsArr, n)
    printTable(table, rowsArr, n)
    
    function selectionSort(rowsArr,  n)
    {
        let minIdx;
        let row1;
        let row2;
        let x;
        let y;
        // One by one move boundary of unsorted subarray
        for (let i = 1; i < n-1; i++)
        {
            // Find the minimum element in unsorted array
            minIdx = i;
            for (let j = i + 1; j < n; j++){
                // get the amount value for rows[i] and rows[i + 1]
                row1 = rowsArr[minIdx].childNodes[5].innerHTML;
                row2 = rowsArr[j].childNodes[5].innerHTML;
                //console.log(row1 + row2);
                // make sure amount is positive
                x = Math.abs(parseFloat(row1));
                y = Math.abs(parseFloat(row2));
                //console.log('row1: ', x, 'row2: ', y)
                if (y < x){
                    minIdx = j;
                }
            }
            
            // Swap the found minimum element with the first element
            swap(rowsArr,minIdx, i);
        }
    }
    
    function swap(rowsArr ,xp, yp)
    {
        let temp1 = rowsArr[xp];
        let temp2 = rowsArr[yp];
        rowsArr.splice(xp, 1, temp2);
        rowsArr.splice(yp, 1, temp1);
    }

    function printTable(table, rowsArr,n){
        for (let i = 1; i < n; i++){
            console.log(rowsArr[i]);
            table.rows[i] = rowsArr[i];
        }
    }
}


CATEGORIES SORT:

function categorySort(){
    let table = document.getElementById('transaction-table');
    let rows;
    let switching = true;
    let i, x, y;
    let categories = [];
    let current;
    rows = table.rows;
    for (let j = 1; j < rows.length; j++){
        current = rows[j].childNodes[9].lastChild.value.toLowerCase();
        console.log(current)
        if (!categories.includes(current)){
            categories.push(current);
        }
    }
    console.log(categories)
    while (switching){
        switching = false;
        for (i = 1; i < (rows.length - 1); i++){
            shouldSwitch = false;
            // get the transaction date and convert it to a Date object
            x = rows[i].childNodes[9].lastChild.value.toLowerCase();
            y = rows[i + 1].childNodes[9].lastChild.value.toLowerCase();
            // if row[i] date is greater than row[i + 1] date, switch them
            if (x == categories[i]){
                shouldSwitch = true;
                break;
            }
        }
        if (shouldSwitch) {
            rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
            switching = true;
        }
    }
}